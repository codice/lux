package lux.gen;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

import net.sf.saxon.expr.ArithmeticExpression;
import net.sf.saxon.expr.BinaryExpression;
import net.sf.saxon.expr.ContextSwitchingExpression;
import net.sf.saxon.expr.Expression;
import net.sf.saxon.expr.FilterExpression;
import net.sf.saxon.expr.GeneralComparison;
import net.sf.saxon.expr.IdentityComparison;
import net.sf.saxon.expr.Literal;
import net.sf.saxon.expr.SlashExpression;
import net.sf.saxon.expr.ValueComparison;
import net.sf.saxon.expr.VennExpression;
import net.sf.saxon.om.Axis;
import net.sf.saxon.type.AtomicType;
import net.sf.saxon.type.BuiltInAtomicType;
import net.sf.saxon.type.ItemType;
import net.sf.saxon.type.Type;
import net.sf.saxon.type.TypeHierarchy;
import net.sf.saxon.value.Int64Value;

/** Grows expressions by generating, culling, and combining expressions.
 * 
 * @author sokolov
 *
 */
public class ExprBreeder implements Iterable<Expression> {
    
    private final ExprGen generator;
    // Expressions generated by previous generations
    private ArrayList<Expression> primitives = new ArrayList<Expression>();
    
    public ExprBreeder (ExprGen generator) {
        this.generator = generator;
        
        // popuplate the herd with some literals and axis expressions
        int fibValues[] = new int[] { 1, 2, 3, 5, 8, 13, 21, 34 };
        for (int i = 0; i < generator.getBreadth(); i++) {
            Literal intLiteral = new Literal (new Int64Value(fibValues[i]));
            primitives.add(intLiteral);
            primitives.add(generator.genRandomStringLiteral());
            // Filter out primitives that will never match anything starting from a document-node()            
        }
        byte axisMask = (1<<Axis.CHILD) | (1<<Axis.DESCENDANT) | (1 << Axis.DESCENDANT_OR_SELF);
        for (Expression expr : generator.genAxisExpressions (axisMask)) {
            primitives.add (expr);
        }
    }
    
    public Collection<Expression> getPrimitives () {
        return primitives;
    }

    private boolean invalidExpression(Expression expr) {
        TypeHierarchy th = generator.getSaxon().getConfig().getTypeHierarchy();
        if (expr instanceof SlashExpression || expr instanceof FilterExpression) {
            // don't apply axes to atomic values or text nodes
            ItemType itemType = ((ContextSwitchingExpression)expr).getControllingExpression().getItemType (th);
            if (itemType.isPlainType() || itemType.getPrimitiveType() == Type.TEXT) {
                // TODO: check for attribute, processing instruction, namespace?
                return true;
            }
        }
        else if (expr instanceof IdentityComparison || expr instanceof VennExpression) {
            // TODO: prevent these from being generated in the first place
            BinaryExpression bin = (BinaryExpression) expr;
            Expression [] operands = bin.getOperands();
            if (operands[0].getItemType(th).isAtomicType() || operands[1].getItemType(th).isAtomicType()) {
                return true;
            }
        }
        else if (expr instanceof ArithmeticExpression) {
            // TODO: prevent these from being generated in the first place
            BinaryExpression bin = (BinaryExpression) expr;
            Expression [] operands = bin.getOperands();
            // make sure both operands are not known to be non-numeric
            if (operands[0].getItemType(th) == BuiltInAtomicType.STRING || operands[1].getItemType(th) == BuiltInAtomicType.STRING) {
                return true;
            }
        }
        else if (expr instanceof ValueComparison || expr instanceof GeneralComparison) {
            Expression [] operands = ((BinaryExpression)expr).getOperands();
            if (operands[0].getItemType(th).isAtomicType() && operands[1].getItemType(th).isAtomicType()) {
                AtomicType t0 = (AtomicType) operands[0].getItemType(th);
                AtomicType t1 = (AtomicType) operands[1].getItemType(th);
                return !(t0.isSameType(t1));
            }
        }
        return false;
    }
    
    // TODO: add offspring, merge with the herd and cull
    
    public class ExprIter implements Iterator<Expression> {
        
        // the index of the next kind of expression to generate
        private int nextExpr;
        // the number of argument combinations that have been used
        // to generate expressions with the expression indicated by nextExpr.
        // This acts as an inner loop variable for the iteration
        private int argsLeft;
        
        ExprIter () {
            nextExpr = 0;
            initExpr();
        }
        
        private void initExpr () {
            if (nextExpr >= generator.getTemplateCount()) {
                argsLeft = 0;
            } else {
                argsLeft = generator.getTemplate (nextExpr).computeArgFanout (primitives.size(), generator.getBreadth());
            }
        }
        
        public boolean hasNext() {
            return nextExpr < generator.getTemplateCount() && argsLeft > 0;
        }

        /**
         * For each expression template, generate an expression for every combination of arguments.
         * 
         */
        public Expression next() {
            Expression expr;
            do {
                expr = generator.createNumberedExpression (nextExpr, argsLeft, primitives);
                if (--argsLeft <= 0) {
                    ++nextExpr;
                    initExpr();
                }
            } while (invalidExpression(expr) && hasNext());
            return expr;
        }

        public void remove() {
            throw new UnsupportedOperationException ();
        }
        
    }

    public Iterator<Expression> iterator() {
        return new ExprIter();
    }

}
