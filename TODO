* High-level goals
** optimize searching
xpath analysis yielding index operations as much as possible
** compelling use cases
It's easier to make the case when you have a stack including search api,
gui etc.  Nevertheless we do offer the core capability: data storage (no
transactions), automatic indexing, query via xpath and retrieval of nodes,
values and documents.  Might be nice to extend the solr admin with a query
interface?  The next step of course is an xquery app server, etc.
Integration w/Oxygen?
** other optimizations
*** reduce parsing/serialization time
*** xpath execution time
** xpath 2
** xquery
** updates?
* optimize XPath searching
There are a few more things we can optimize using the "basic" indexing setup
** pre-evaluate some functions, like aggregates:

In cases where we can do this (argument expression is evaluated in the
QueryContext, ie there is no current node, or the argument is the
collection() function), rewrite/wrap/intercepty the function to an internal method
(lux:count) that we implement by recursing into a nested query/eval.  

In such a case we'd like to do static analysis of the argument expression
to see if it is query-exact.  If we can prove that the db query result
count will equal the expression result count, then we can replace the
count() expression with an (indexed, more efficient) query-count()
expression.

This could also hold for max/min when we have an appropriate field.  Maybe
we can even help out w/aggregates like sum/avg?

More complex would be something like: count(//a) + count(//b) ?

This is hard to do w/Jaxen b/c we would really like to supply our own
Expression objects for this purpose, and that's not possible due to an
overly rigid constructor in JaxenHandler.  So we would need to start
modifying Jaxen.

In Saxon, my first thought was to do this using a CodeInjector, which
provides a way to come in sideways and completely rewrite part of the parse
tree, after parsing.  But it is associated with tracing and its use seems
to come with some possibly unwanted side effects, like disabling
promotions?  ExpressionVisitor looks like a hook, but isn't really - it's
more of a utility class.  

So the best possibility here is to supply our own FunctionLibrary - can we
do that?  It looks as if we would have to extend StaticQueryContext,
provide our own compileQuery method (copying - it's a short method) and
creating our own version of QueryModule that overrides getFunctionLibrary()
- this comes with a scary warning, though.  This is all do-able, but
limited to functions.  If we wanted to be able to rewrite aribtrary
expressions (which we do!), we'd need some other mechanism.  And this is
looking really painful in Saxon.  It's really not designed for this kind of
extensibility, is it?  XQueryExpression, which is what you actually
execute, is immutable and locked down in various ways.  

Expression you can walk and visit, but you can't really do anything with
that directly.  Still one possibility is to walk the Expression tree,
rewriting into a new tree, say, and then output the new query as a string -
rewrite it literally, as source code.  But we could use some other parser
for that?  There are two that I've found - an ANTLR one, and a JavaCC one.

*** root()
*** count()
across multiple documents
*** node-uri(), document-uri()
** optimize pagination when we know that #count=#estimate
eg where a sequence will always return one result per document, and we know
that we can match the documents exactly by query.  For example:
*** /descendant::foo[1] or /descendant::foo[last()]
If we had accurate element counts/positions we could extend this to any
constant expression in the predicate.  Also expressions with position() =
same
* Advanced Indexing techniques
** index paths
** index text and values
parameterize existing indexing classes
** index XML structure
* Saxon integration
as a pluggable option
** parse/eval hooks for extension/query rewriting
*** ExpressionParser accepts a CodeInjector
Set a CodeInjector which can be used to modify or wrap expressions on the
tree as the expression is parsed and the tree is constructed. This is
typically used to add tracing code.
*** ExpressionParser.parse accepts a user-supplied StaticContext/Configuration
This can provide function bindings, and represent the lux context generally
So we could for example replace certain functions with our own
implementations that provide simplify() methods which are aware of query
context.  These would either simplify down to the builtin system function,
or they'd simplify to a query-based implementation.
*** Optimizer performs some very specific optimizations
This doesn't look like a useful general-purpose extension point - it
represents Saxon EE optimizations
*** ExpressionVisitor
visitor.simplify() is called when compiling, after parsing

If we provided our own ExpressionVisitor, it could have knowledge of
certain simplifications and apply them.  But this isn't really feasible as
ExpressionVisitor is created using a static utility method which is called
all over saxon.

*** StaticQueryContext
can override compileQuery, set a CodeInjector
*** StaticContext
This provides the function library, for example.  But is not really
involved in parsing or compile-time optimization.

** use tinytree for storage
** use Saxon as XPath / XQuery evaluator
** TinyTree in ifpress
* Testing
** Document Set
using hamlet for lucene tests, solr config + fake docs for solr
** Query Set
evolving
** Performance Measurement
* Basic Implementation
** SOLR Pagination
when start > 1, change doc-start = 1 and scan forward
*** opto when query minimal
then set doc-start = start
**** minimal document results, or minimal counts only
can skip XPath step entirely
*** cache result navigation info in Solr
if we've computed which document contains xpath X position A, and a request
comes in for xpath X position B, and B > A, we can start at A and scan
forward.  This can be a very small cache.  The idea is that one consumer is
skipping around in a result set.  The main case is to optimize is scanning
through an entire large result set.
** Counting
count (//foo)
*** need to handle functions at outermost scope
expressions like (//foo)[1] too
** cleanup API, rename classes
This is better now - but still not sure about LuXPath
once we have a few implementations done, revisit the naming
* Solr integration
** namespaces
*** in QParser config
*** in query localnames
** marshal XML types
preserve xpath result types (nodes and xdm atomic types) across Solr's
comms This is a bit better now.  But too much parsing/unparsing.
** configure XPathSearchComponent, XPathQParser, LuxProcessor
*** xml field name
*** namespace-aware
for parser and update processor
* Administrivia
** svn
** domain/namespace
lux.* is unavailable
luxpath.net/org are available
** distribution
* Highlighting
* desiderata
** XML namespaces
Don't pollute queries with horrible namespace declarations.  Allow
namespaces to be declared in configuration only.  Also allow namespace
support to be disabled, in which case index QNames directly.
** sorting
only document order for now; XPath doesn't allow for any other sort order,
but of course we would like to sort the documents too...
