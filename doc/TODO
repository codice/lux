* Packaging / distribution
What is the goal for a first public release?  Is it better to just get
something out there and invite users / collaboration?  The best thing will
be to make sure whatever we put is out very high quality, and complete
within some limited sphere.  But not to wait too long, since we want to
test our ideas in the marketplace, and start to drum up interest and
support.
** sourceforge?
At some point we'll want to put this up in a collaboration environment.
Consider Collabnet?  GitHub?
** ifpress

** lucene
mention on the mailing list?
** xml-dev
mention on the mailing list?
** svn
** domain/namespace
lux.* is unavailable
luxpath.net/org are available
** licensing. 
Saxon licensing doesn't seem to be an issue?  Review
Mozilla license, but if we are committed to open source there's no problem?
If we do commit to saxon (seems like the best way to focus on indexing and
query optos?), should probably scrap Jaxen support, or stop extending its
tests.  Already the Lucene and Solr integration is too tied to the specific
impl.  Alternatively, see this as an oppty to build a good abstraction
layer.
* Plans
** xquery abstraction
We dumped Jaxen - it's just too old to be of interest.  So the only impl we
have right now is based on Saxon.  We should maintain an abstraction layer
though.  ADVANTAGES of a built-in xquery parser: decouple from Saxon API -
this is actually a big deal.  SUPPORT for xpath 1.0 in JDK: this way we can
run out of the box in Lucene with no additional jars.
** benchmark framework
Eventually will want to scale up, perform repeats, report timings in a
better way, etc.  For now unit tests seem fine.
** indexer/query generator plugin
To make it easier to choose which indexes to use, this should be pluggable.
Indexers can either be event-driven or xpath-based (post processed).
* Advanced Indexing techniques
** index text and values
parameterize existing indexing classes
** index XML structure
"shred" or "fragment" - should help w/large docs.. Additional query
optimizations will be possible (like indexed //foo without the need for any
post-evaluation, joins, etc).
* Saxon integration
** compatible API
Expose some kind of API like Saxon's?
** PTree binary storage
Use tinytree for storage; evaluate the perf improvement from this.  Could
use Ptree if you have saxon-PE+.  Or could build a replacement (maybe for
in house use, but don't release).  Actually this proves to be difficult
without totally taking over Saxon.
** TinyTree in ifpress
** check whether our code works w/9.1 (Saxon B) ?
** saxon-PE/HE
evaluate perf improvements
*** better optimization?
especially collapsing document-sorting expressions
* Testing
** Document Set
using hamlet for lucene tests, solr config + fake docs for solr
** Performance Measurement
* Basic Implementation
** SOLR Pagination
when start > 1, change doc-start = 1 and scan forward
*** opto when query minimal
then set doc-start = start
**** minimal document results, or minimal counts only
can skip XPath step entirely
*** cache result navigation info in Solr
if we've computed which document contains xpath X position A, and a request
comes in for xpath X position B, and B > A, we can start at A and scan
forward.  This can be a very small cache.  The idea is that one consumer is
skipping around in a result set.  The main case is to optimize is scanning
through an entire large result set.
* Solr integration
** namespaces
*** in QParser config
*** in query localnames
** marshal XML types
preserve xpath result types (nodes and xdm atomic types) across Solr's
comms This is a bit better now.  But too much parsing/unparsing.
** configure XPathSearchComponent, XPathQParser, LuxProcessor
*** xml field name
*** namespace-aware
for parser and update processor
* Highlighting
* desiderata
** XML namespaces
Don't pollute queries with horrible namespace declarations.  Allow
namespaces to be declared in configuration only.  Also allow namespace
support to be disabled, in which case index QNames directly.
** sorting
only document order for now; XPath doesn't allow for any other sort order,
but of course we would like to sort the documents too...
