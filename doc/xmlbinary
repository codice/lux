fast, reasonably compact, parse-free, recursive format

fast - for what?  XPath eval, and I/O

compact - not much different from text XML

recursive - so that elements can be chopped out as results, but no need for
modification otherwise.

each node has a header with structure info encoded in it, followed by its
own name and/or value.  We want an element's name local to it (not interned
in a symbol table) so it can be easily ripped out and handed off.  Although
perhaps the entire symbol table could be passed around in memory, or
duplicated in storage, or stripped if need be?

Structure to support XPath; navigate the axes:

self, parent, child, descendant, ancestor, preceding, following,
preceding-sibling, following-sibling, attribute, namespace

It is possible to start in the middle and navigate up and back since we
store all the necessary axes.

We can chop a node out of context and make it a standalone node value by
zeroing out its parent, following and preceding and sibling pointers and
fixing up the length. - 

what about preceding and following pointers in child content of an excised
element?  Those will end up dangling.  Maybe we have to have bounds checks?

length is length of the entire object, including the length VINT; all the
bytes from start-address to start-address+length are part of an object.

STRING: length as VINT, value as UTF-8 bytes

ATTRIBUTE:
      BYTE type,
      VINT length,
      STRING name (incl prefix)
      STRING namespace (optional)
      STRING value
      VINT parent-offset
      VINT preceding offset
      VINT following offset

CONTENT NODE (element or text):
      BYTE type,
      VINT length
      XXXX value
      VINT parent-offset
      VINT prev-sibling offset
      VINT preceding offset
      VINT following offset

offset=0 means the axis is empty 

COMMENT, PI, CDATA, TEXT: NODE with value=text

ELEMENT: NODE with value:
      STRING name (incl prefix)
      STRING namespace (optional)
      CONTENT content - contains all child content

DOCUMENT:
      BYTE type
      VINT length
      CONTENT content

--------------------

redundancy: 

following-sibling offset = following-offset=length ? 0 : length


--------------------

encoding size:

supposing VINTs are mostly 1.5 bytes on average

element w/text becomes:

16 extra bytes as opposed to text encoding which has:

<name>...</name>

5 bytes + name length repeated

with name interning, we could reduce that - in a large file with < 128 names,
every name could be represented in a byte.

---------------------

Another possibility is to retain the original XML document and precede it
with this index structure.  This would make serialization trivial at the
cost of some additional space. however we could use xmlbin as our wire
format directly if we implement xpath on the client using it (for the xml
mapper) and if we can interface it to saxon somehow.

Hmm -- look at using TinyTree directly; it implements these ideas already,
and could slot in to saxon directly, of course.