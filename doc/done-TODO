* optimizations
** basic indexing support: qname retrieval speeds queries when the names are selective
** count() is optimized for a special case:
when the query for the argument can be shown to have the same cardinality;
basically this is when the argument is a simple path expression equivalent
to these forms:

//element/root()
//element/ancestor::document-node()
(/)[.//element]

etc..
*** also in that case, when not counting (just returning documents),
we save some time by not executing the xpath.
** exist(), empty()
short-circuit counting; exits search as soon as a doc is found. not() is
handled as well since saxon converts not(node-sequence) into
not(exists(node-sequence)).
** count(//a) + count(//b)
** lazy result iteration
Rather than trying to figure out in advance how many results will be
required, allow the caller to pull results lazily.  Tested this with exists()
and empty(), and with count() > N.
*** subsequence(); [1], etc.
This sometimes optimizes properly, but not in every case it could.  There
are difficulties because of the need to preserve document ordering.
** document identity
Need to cache documents, at least for the duration of a single query, so we
don't recreate the same document twice: otherwise Saxon thinks they are
different.
** predicate submersion
Express paths returning documents (say ending with root()) as
search()[path] so that the path doesn't need to be sorted in document
order, enabling lazy evaluation.
* lux components
** Translator
converts Saxon's internal Expression tree to a Lux AbstractExpression tree.
** PathOptimizer
optimizes an AbstractExpression tree using Lucene searches with element and
attribute name indexes.
*** ExpressionVisitor
machinery for optimizers and other tree visitors like UnOptimizer.
** Indexer
