* query API
lux:search now accepts queries formatted as node trees using the Lucene XML
query parser scheme.  The indexes provided include node (QName) path
indexes and node word indexes.
** full text search *across the whole document*
eg lux:search("phrase to find") will match documents containing the phrase.
** full text search *spanning all descendants* of a node
eg //foo["phrase to find"] would match <foo><a>phrase<a> to <b>find</b></foo>
*** Note: elements introduce token boundaries
eg //foo["phrase to find"] would match <foo><a>phrase<a>to<b>find</b></foo>
* storage
TinyBinary yields 5-20x speedup in document read time.  Documents
are *larger* though - about twice as big, even using utf-8 encoding for the
text.  Apparently 19 bytes per node is expensive.
* optimizations
** basic indexing support: qname retrieval speeds queries when the names are selective
** count() is optimized for a special case:
when the query for the argument can be shown to have the same cardinality;
basically this is when the argument is a simple path expression equivalent
to these forms:

//element/root()
//element/ancestor::document-node()
(/)[.//element]

etc..
*** also in that case, when not counting (just returning documents),
we save some time by not executing the xpath.
** exist(), empty()
short-circuit counting; exits search as soon as a doc is found. not() is
handled as well since saxon converts not(node-sequence) into
not(exists(node-sequence)).
** count(//a) + count(//b)
** lazy result iteration
Rather than trying to figure out in advance how many results will be
required, allow the caller to pull results lazily.  Tested this with exists()
and empty(), and with count() > N.
*** subsequence(); [1], etc.
This sometimes optimizes properly, but not in every case it could.  There
are difficulties because of the need to preserve document ordering.
** document identity
Need to cache documents, at least for the duration of a single query, so we
don't recreate the same document twice: otherwise Saxon thinks they are
different.
** predicate submersion
Express paths returning documents (say ending with root()) as
search()[path] so that the path doesn't need to be sorted in document
order, enabling lazy evaluation.
*** This does seem to have worked
I found this note in impl-TODO, but at the moment we don't seem to have any
problem like this (see SearchTest.pathOrder which retrieves 120 nodes from
6 documents in //SCENE/root()//ACT).  It seems to have gotten sorted out
when we implemented path indexes, although I'm not sure why since we still
emit a purely qname-based query: SCENE AND ACT.

**** removed lux:root()
subsumed by predicate optimization

**** note about root()
Background: the evaluator has to ensure that sequences of nodes are unique
and in document order.  Our Optimizer calculates and asserts document
order, but doesn't detect when there are multiple copies of the same node.
This can occur due to doc() and root().  Maybe other functions?  A sequence
like //foo/root() returns documents, but the evaluator iterates over nodes
(//foo) in each document, and returns each document once for each
occurrence of foo in its document.
** optimize contains()
** predicates with atomic/node comparisons 
like [foo = "foo"]
* indexes
XmlIndexer manages multiple index options, and we pass it around so consumers
of the index know what is available there.
** qname index
** path index
** value indexes
index key: <QName> | <first N chars of value>
we could have path value indexes too:
{} <QName> <QName> ... | <first N chars>
in fact this index can probably just replace the QName or path index
** word indexes
Now works using single fulltext field with terms that incorporate the field
name so we can do near queries across different element names, and
implement transparent elements (like ML phrase-through).
*** QNameAttribute / Impl / Factory / Filter
We provide a QName-based analysis chain wrapped around StandardTokenizer /
LowerCaseFilter.
*** create QNameTextTokenStream
returned by QNameTextField
*** Adding character offsets
so we can support highlighting.  We also need this for compatibility
w/ifpress - so we don't need two separate xml_text fields Compared
parsing/indexing speed with and without offsets: there was a 3% slowdown in
the overall time to index when offsets were added (see IndexTest below).
**** Measured indexing speed
IndexTest.testIndexFullTest 
Without offsets: 4481 4690 4677 4637 4576
With offsets: 4752 4244 4740 4891 4873
throwing out the min and max, averaging, the difference is about 150 ms, or
about 3% difference.
** user search function
Supporting full text queries; we do have lux:search (xs:string); however
the query syntax is bizarre since you must specify an element name for
every token using eltname{namespace}:word.  Conversely we have lux:search
(element()), but no xquery helper functions for constructing the queries.
However that seems to be the way to go.
*** query syntax
**** lux:query("element", "value")
***** shorthand: :element:value
**** lux:query("prefix:element", "value")
uses namespace bindings declared in the query
***** shorthand: prefix:element:value
**** lux:query("@attribute", "value")
***** shorthand: :@attribute:value
**** lux:query("element/@attribute", "value")
just a simple and-query of "element/@attribute" and "@attribute=value"
***** shorthand: :element/@attribute:value
**** lux:and(), lux:or(), lux:not()
*** modified string query parser
standard lucene query parser syntax where field names may contain "@" and
namespace *prefixes*.  Post-process to prefix terms with element/attribute
names.
* tests
** testing doc() and collection()
** search test coverage
Run search tests for everything in query test, comparing "raw" against
indexed results.
** XQuery Test Suite
** XQuery!
running XQTS now - down to 1305 failures out of 12008 tests over a few days
we got it down to 147 w/44 ignored.  Now 7 tests fail.  
*** 1 is a test harness glitch
*** 1 is due to no schema support
*** 3 are due to no support for type in:
element(foo,xs:type) 
*** 2 are due to an unexplained compile problem with the context item (.)
Then, running on a larger test suite: Ran 18623 tests; 29 tests fail -
mostly these are related to collection() and a few unicode surrogate
issues.
* lux components
** Translator
converts Saxon's internal Expression tree to a Lux AbstractExpression tree.
** PathOptimizer
optimizes an AbstractExpression tree using Lucene searches with element and
attribute name indexes.
*** ExpressionVisitor
machinery for optimizers and other tree visitors like UnOptimizer.
** Indexer
*** base-uri
We now attach a base uri to each result document
** Lux Function Library for XPath/XQuery 
lux:search, lux:count, lux:exists execute a lucene query, returning
documents, count, and boolean respectively, which are then processed by the
evaluator as part of an enclosing XPath or XQuery expression. Currently
used only internally by the optimizer, but we intend to provide
user-callable versions as well supporting some form of lucene query syntx.
*** optimize absolute (rooted) context-free expressions
The optimizer considers inserting one of the lux function whenever such a
sub-expression occurs.
** Solr integration
UpdateProcessor and SearchComponent
** XQuery Evaluator
* packaging
** solr request handler
restored to working order
** MPL license
* code cleanup
** reorganized class/package names
moved stuff out of lux package into lux.search; created lux.query for
queries.
** shorten xml index field names?
to make it easier to type queries.  Maybe make the default field name be
something reasonable, like xml_text?  then use lux_att_name, lux_elt_name,
lux_path?  This is fine, but requires schema changes for the Solr version.
* bug fixes
** query quoting
quote operators like and, or, not, n, w.  If we have these as QNames, we'll
fail!  Also - quote quotes, etc.  These could appear in namespace uris, eg.
Maybe we did that part already?
** trailing funcall()
was being treated as root()
