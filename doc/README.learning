I had the idea that you could learn test cases and/or index configuration
from a sample dataset.  A sort of datamining approach?

* Learning
Iterative expression generator using the term vocabulary (values and node
names) from the data set.
** extract the vocabulary
** generate expressions
*** re-inject terms at every level
** expression generator
1. start with a fixed set of QNames and literals

2. assign a fixed probability to each expression and to the termination condition
3. generate random expressions!

Use a seed, and a number of expressions to generate a predictable run
*** baseline evaluation
Evaluate the expression across a set of documents using a reference system.
Keep track of the number of documents that generate non-empty results, the
total number of results, and the number of different results.  Classify the
expressions as: empty, constant, single-valued (per doc), across all the
documents
*** query-optimized evaluation
Re-evaluate the same expression using the query optimizer.  
**** Ensure the results are the same.
**** check for optimization
Simply compare evaluation speed; but also calculate a predicted
optimization and compare.  We'd expect expressions to optimize well if they
don't match many documents, or if they are constant, and maybe if they're
single-valued.
**** Keep statistics
1. ERRORS flag any queries with incorrect results
2. SURPRISES queries that optimize more or less than expected
3. GOODNESS overall improvement due to optimization
** Label the tests with expected optimizations
*** query text
This will depend on the indexes available and the query plan chosen.
*** facts
minimal, exact, counting: Is it possible to compute these emprically?  It's
certainly possible to disprove a fact by finding a counter-example.  There
may not be sufficient documents for this in the XQTS?
*** possible strategy
**** baseline from Saxon
Run the XQTS using Saxon alone, executing each expressions against the
entire collection of test documents, recording the results
**** test using Lux
Run the XQTS in the same way using Lux and compare results (and time, of
course).
**** optimize and repeat
Apply additional optimizations where possible
