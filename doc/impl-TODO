* test optimizations
** not() 
** node-uri(), document-uri()
** pagination
optimize subsequence
short-circuit evaluations, etc.
*** optimize pagination when we know that #count=#estimate
eg where a sequence will always return one result per document, and we know
that we can match the documents exactly by query.  For example:
**** /descendant::foo[1] or /descendant::foo[last()]
If we had accurate element counts/positions we could extend this to any
constant expression in the predicate.  Also expressions with position() =
same
** lazy result iteration
Rather than trying to figure out in advance how many results will be
required, allow the caller to pull results lazily.  Test this with exists()
and empty(), and with count() > N.  Yaah this seems fraught with peril -
see NOTES.
* PTree binary storage
* API packaging
** rename Saxon
Lux? Evaluator?
** configuration
*** Lucene field names
*** storage format
text vs PTree
*** Object Model
Saxon Xdm vs JDOM vs DOM vs ?
*** language
XPath / XQuery
